<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head>
        <meta charset="utf-8">
        <title>Wonderio_map</title>
        <style media="screen">
            canvas {
                border: lightskyblue 1px dashed;
            }
        </style>
    </head>
    <body>
        <h3>32784</h3>
        <canvas id="id-canvas" data-action='draw_tile' data-type='source' width="640" height="640"></canvas>
        <canvas id="id-canvas-sprite" data-action='draw_tile' data-type='tile' width="160" height="320"></canvas>
        <canvas data-action='draw_tile' data-type='tile' width="160" height="160"></canvas>
        <canvas data-action='draw_tile' data-type='tile' width="480" height="480"></canvas>
        <div class="gua-controls">
            <button data-action='change_offset' data-offset='-1024'>-1024</button>
            <button data-action='change_offset' data-offset='-16'>-16</button>
            <button data-action='change_offset' data-offset='16'>+16</button>
            <button data-action='change_offset' data-offset='1024'>1024</button>
        </div>
        <script type="text/javascript">
            /*
                8x8 像素每个图块
                2 bits 每个像素 8 bits = 1 byte
                16 bytes 一个图块


                每页 8X8 个图块  宽高 各 64 像素
            */

            const e = sel => document.querySelector(sel)
            const log = console.log.bind(console)

            const ajax = request => {
                let r = new XMLHttpRequest()
                // true 代表可以异步
                r.open(request.method, request.url, true)
                r.responseType = 'arraybuffer'
                r.onreadystatechange = event => {
                    if (r.readyState == 4) {
                        request.callback(r.response)
                    }
                }
                r.send()
            }

            const bindEvents = () => {
                e('body').addEventListener('click', event => {
                    let action = event.target.dataset.action
                    actions[action] && actions[action](event)
                })

                window.addEventListener('keydown', event => {
                    log('event', event.key)
                    if (event.key == 'p') {
                        window.paused = !window.paused
                    }
                })
            }

            const drawNes = bytes => {
                // 78 69
                // 78: 0100 1110
                // 69: 0100 0101

                let canvas = e('#id-canvas')
                let context = canvas.getContext('2d')
                context.clearRect(0, 0, canvas.width, canvas.height)
                let blockSize = 8
                let pixelSize = 8
                let pixelWidth = 10
                let numberOfBytesPerBlock = 16
                for (let i = 0; i < blockSize; i++) {
                    for (let j = 0; j < blockSize; j++) {
                        let x = j * pixelSize * pixelWidth
                        let y = i * pixelSize * pixelWidth
                        let index = window.offset + (i * 8 + j) * numberOfBytesPerBlock
                        drawBlock(context, bytes.slice(index), x, y, pixelWidth)
                    }
                }
            }

            const actions = {
                change_offset(event) {
                    let offset = Number(event.target.dataset.offset)
                    log('offset', offset)
                    window.offset += offset
                    e('h3').innerHTML = window.offset
                    drawNes(window.bytes)
                },
                draw_tile(event) {
                    let target = event.target
                    log('target', target)
                    let rect = target.getBoundingClientRect()
                    let x = event.clientX - rect.left
                    let y = event.clientY - rect.top
                    // i j 算出在 tile 中的第几个
                    let i = Math.floor(x / 80)
                    let j = Math.floor(y / 80)
                    let bytesPerBlock = 16
                    //
                    let type = target.dataset.type
                    if (type == 'source') {
                        let offset = i * bytesPerBlock + j * bytesPerBlock * 8
                        window.tileOffset = offset + window.offset
                    } else if (type == 'tile') {
                        let data = window.bytes.slice(window.tileOffset)
                        log('if target', target)
                        drawSprite(data, target, i, j, 1, 1)
                    }
                }
            }

            const drawBlock = (context, data, x, y, pixelWidth) => {
                const colors = [
                    'white',
                    '#FF0000',
                    '#FFAA4E',
                    '#884400',
                ]
                let w = pixelWidth
                let h = pixelWidth
                for (let i = 0; i < 8; i++) {
                    let p1 = data[i]
                    let p2 = data[i + 8]
                    for (let j = 0; j < 8; j++) {
                        // 8 bits per line
                        // 78: 0100 1110
                        // 69: 0100 0101
                        // 在 j 循环中 每一次 画一个像素点
                        // c: color
                        let c1 = (p1 >> (7 - j)) & 0b00000001
                        let c2 = (p2 >> (7 - j)) & 0b00000001
                        let pixel = (c2 << 1) + c1
                        if (pixel != 0) {
                            let color = colors[pixel]
                            context.fillStyle = color
                            let px = x + j * w
                            let py = y + i * h
                            context.fillRect(px, py, w, h)
                        }
                    }
                }
            }

            const drawSprite = (data, canvas_draw, offsetX, offsetY, w, h) => {
                let context = canvas_draw.getContext('2d')
                let pixelsPerBlock = 8
                let pixelWidth = 10
                let blockSize = pixelsPerBlock * pixelWidth
                let offset = 0
                for (let i = 0; i < h; i++) {
                    for (let j = 0; j < w; j++) {
                        let x = (offsetX + j) * blockSize
                        let y = (offsetY + i) * blockSize
                        let pixels = data.slice(offset)
                        drawBlock(context, pixels, x, y, pixelWidth)
                        offset += 16
                    }
                }
            }

            const __main = () => {
                window.paused = false
                window.offset = 32784
                let tileOffset = 32784
                let request = {
                    method: 'GET',
                    url: 'mario.nes',
                    callback(r) {
                        window.bytes = new Uint8Array(r)
                        log('bytes', bytes)
                        drawNes(bytes)
                        // 闭包 外部的变量被内部的函数使用
                        // let step = 0
                        // let bytesPerBlock = 16
                        // let tilesPerSprite = 8
                        // let bytesPerSprite = bytesPerBlock * tilesPerSprite
                        // setInterval 不断的重新画它
                        // setInterval(function(){
                            // let offset = tileOffset + step * bytesPerSprite
                            // // drawSprite(bytes.slice(offset))
                            // if (window.paused) {
                            //     // pause
                            // } else {
                            //     step++
                            //     // 4 个画面循环
                            //     step %= 4
                            // }
                        // }, 200)
                    },
                }
                ajax(request)

                bindEvents()
            }

            __main()
        </script>
    </body>
</html>
